// Code generated by Prisma (prisma@1.30.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  authenticateUserPayload: (
    where?: AuthenticateUserPayloadWhereInput
  ) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  group: (where?: GroupWhereInput) => Promise<boolean>;
  invite: (where?: InviteWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  loggedInUserPayload: (
    where?: LoggedInUserPayloadWhereInput
  ) => Promise<boolean>;
  signupUserPayload: (where?: SignupUserPayloadWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  authenticateUserPayloads: (
    args?: {
      where?: AuthenticateUserPayloadWhereInput;
      orderBy?: AuthenticateUserPayloadOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AuthenticateUserPayload>;
  authenticateUserPayloadsConnection: (
    args?: {
      where?: AuthenticateUserPayloadWhereInput;
      orderBy?: AuthenticateUserPayloadOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AuthenticateUserPayloadConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventPromise;
  events: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Event>;
  eventsConnection: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EventConnectionPromise;
  file: (where: FileWhereUniqueInput) => FilePromise;
  files: (
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<File>;
  filesConnection: (
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FileConnectionPromise;
  group: (where: GroupWhereUniqueInput) => GroupPromise;
  groups: (
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Group>;
  groupsConnection: (
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GroupConnectionPromise;
  invite: (where: InviteWhereUniqueInput) => InvitePromise;
  invites: (
    args?: {
      where?: InviteWhereInput;
      orderBy?: InviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Invite>;
  invitesConnection: (
    args?: {
      where?: InviteWhereInput;
      orderBy?: InviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => InviteConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemPromise;
  items: (
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Item>;
  itemsConnection: (
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ItemConnectionPromise;
  loggedInUserPayload: (
    where: LoggedInUserPayloadWhereUniqueInput
  ) => LoggedInUserPayloadPromise;
  loggedInUserPayloads: (
    args?: {
      where?: LoggedInUserPayloadWhereInput;
      orderBy?: LoggedInUserPayloadOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<LoggedInUserPayload>;
  loggedInUserPayloadsConnection: (
    args?: {
      where?: LoggedInUserPayloadWhereInput;
      orderBy?: LoggedInUserPayloadOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LoggedInUserPayloadConnectionPromise;
  signupUserPayload: (
    where: SignupUserPayloadWhereUniqueInput
  ) => SignupUserPayloadPromise;
  signupUserPayloads: (
    args?: {
      where?: SignupUserPayloadWhereInput;
      orderBy?: SignupUserPayloadOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SignupUserPayload>;
  signupUserPayloadsConnection: (
    args?: {
      where?: SignupUserPayloadWhereInput;
      orderBy?: SignupUserPayloadOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SignupUserPayloadConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAuthenticateUserPayload: (
    data: AuthenticateUserPayloadCreateInput
  ) => AuthenticateUserPayloadPromise;
  updateManyAuthenticateUserPayloads: (
    args: {
      data: AuthenticateUserPayloadUpdateManyMutationInput;
      where?: AuthenticateUserPayloadWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyAuthenticateUserPayloads: (
    where?: AuthenticateUserPayloadWhereInput
  ) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (
    args: { data: EventUpdateInput; where: EventWhereUniqueInput }
  ) => EventPromise;
  updateManyEvents: (
    args: { data: EventUpdateManyMutationInput; where?: EventWhereInput }
  ) => BatchPayloadPromise;
  upsertEvent: (
    args: {
      where: EventWhereUniqueInput;
      create: EventCreateInput;
      update: EventUpdateInput;
    }
  ) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (
    args: { data: FileUpdateInput; where: FileWhereUniqueInput }
  ) => FilePromise;
  updateManyFiles: (
    args: { data: FileUpdateManyMutationInput; where?: FileWhereInput }
  ) => BatchPayloadPromise;
  upsertFile: (
    args: {
      where: FileWhereUniqueInput;
      create: FileCreateInput;
      update: FileUpdateInput;
    }
  ) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createGroup: (data: GroupCreateInput) => GroupPromise;
  updateGroup: (
    args: { data: GroupUpdateInput; where: GroupWhereUniqueInput }
  ) => GroupPromise;
  updateManyGroups: (
    args: { data: GroupUpdateManyMutationInput; where?: GroupWhereInput }
  ) => BatchPayloadPromise;
  upsertGroup: (
    args: {
      where: GroupWhereUniqueInput;
      create: GroupCreateInput;
      update: GroupUpdateInput;
    }
  ) => GroupPromise;
  deleteGroup: (where: GroupWhereUniqueInput) => GroupPromise;
  deleteManyGroups: (where?: GroupWhereInput) => BatchPayloadPromise;
  createInvite: (data: InviteCreateInput) => InvitePromise;
  updateInvite: (
    args: { data: InviteUpdateInput; where: InviteWhereUniqueInput }
  ) => InvitePromise;
  updateManyInvites: (
    args: { data: InviteUpdateManyMutationInput; where?: InviteWhereInput }
  ) => BatchPayloadPromise;
  upsertInvite: (
    args: {
      where: InviteWhereUniqueInput;
      create: InviteCreateInput;
      update: InviteUpdateInput;
    }
  ) => InvitePromise;
  deleteInvite: (where: InviteWhereUniqueInput) => InvitePromise;
  deleteManyInvites: (where?: InviteWhereInput) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (
    args: { data: ItemUpdateInput; where: ItemWhereUniqueInput }
  ) => ItemPromise;
  updateManyItems: (
    args: { data: ItemUpdateManyMutationInput; where?: ItemWhereInput }
  ) => BatchPayloadPromise;
  upsertItem: (
    args: {
      where: ItemWhereUniqueInput;
      create: ItemCreateInput;
      update: ItemUpdateInput;
    }
  ) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createLoggedInUserPayload: () => LoggedInUserPayloadPromise;
  deleteLoggedInUserPayload: (
    where: LoggedInUserPayloadWhereUniqueInput
  ) => LoggedInUserPayloadPromise;
  deleteManyLoggedInUserPayloads: (
    where?: LoggedInUserPayloadWhereInput
  ) => BatchPayloadPromise;
  createSignupUserPayload: (
    data: SignupUserPayloadCreateInput
  ) => SignupUserPayloadPromise;
  updateSignupUserPayload: (
    args: {
      data: SignupUserPayloadUpdateInput;
      where: SignupUserPayloadWhereUniqueInput;
    }
  ) => SignupUserPayloadPromise;
  updateManySignupUserPayloads: (
    args: {
      data: SignupUserPayloadUpdateManyMutationInput;
      where?: SignupUserPayloadWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSignupUserPayload: (
    args: {
      where: SignupUserPayloadWhereUniqueInput;
      create: SignupUserPayloadCreateInput;
      update: SignupUserPayloadUpdateInput;
    }
  ) => SignupUserPayloadPromise;
  deleteSignupUserPayload: (
    where: SignupUserPayloadWhereUniqueInput
  ) => SignupUserPayloadPromise;
  deleteManySignupUserPayloads: (
    where?: SignupUserPayloadWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  authenticateUserPayload: (
    where?: AuthenticateUserPayloadSubscriptionWhereInput
  ) => AuthenticateUserPayloadSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  group: (
    where?: GroupSubscriptionWhereInput
  ) => GroupSubscriptionPayloadSubscription;
  invite: (
    where?: InviteSubscriptionWhereInput
  ) => InviteSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  loggedInUserPayload: (
    where?: LoggedInUserPayloadSubscriptionWhereInput
  ) => LoggedInUserPayloadSubscriptionPayloadSubscription;
  signupUserPayload: (
    where?: SignupUserPayloadSubscriptionWhereInput
  ) => SignupUserPayloadSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC";

export type RSVP = "Yes" | "No" | "Maybe";

export type InviteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "partySize_ASC"
  | "partySize_DESC"
  | "response_ASC"
  | "response_DESC";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "name_ASC"
  | "name_DESC";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "location_ASC"
  | "location_DESC"
  | "date_ASC"
  | "date_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC";

export type GroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AuthenticateUserPayloadOrderByInput =
  | "token_ASC"
  | "token_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FileOrderByInput =
  | "contentType_ASC"
  | "contentType_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "secret_ASC"
  | "secret_DESC"
  | "size_ASC"
  | "size_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "url_ASC"
  | "url_DESC";

export type LoggedInUserPayloadOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SignupUserPayloadOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "token_ASC"
  | "token_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface UserUpdateWithoutInvitesDataInput {
  items?: ItemUpdateManyWithoutBringerInput;
  email?: String;
  username?: String;
  hosting?: EventUpdateManyWithoutHostedByInput;
  password?: String;
  groups?: GroupUpdateManyWithoutMembersInput;
}

export interface AuthenticateUserPayloadWhereInput {
  token?: String;
  token_not?: String;
  token_in?: String[] | String;
  token_not_in?: String[] | String;
  token_lt?: String;
  token_lte?: String;
  token_gt?: String;
  token_gte?: String;
  token_contains?: String;
  token_not_contains?: String;
  token_starts_with?: String;
  token_not_starts_with?: String;
  token_ends_with?: String;
  token_not_ends_with?: String;
  AND?: AuthenticateUserPayloadWhereInput[] | AuthenticateUserPayloadWhereInput;
  OR?: AuthenticateUserPayloadWhereInput[] | AuthenticateUserPayloadWhereInput;
  NOT?: AuthenticateUserPayloadWhereInput[] | AuthenticateUserPayloadWhereInput;
}

export interface ItemCreateManyWithoutBringerInput {
  create?: ItemCreateWithoutBringerInput[] | ItemCreateWithoutBringerInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
}

export interface InviteUpdateManyDataInput {
  partySize?: Int;
  response?: RSVP;
}

export interface ItemCreateWithoutBringerInput {
  quantity: Int;
  name: String;
  event?: EventCreateOneWithoutItemsInput;
}

export interface UserUpdateWithoutHostingDataInput {
  items?: ItemUpdateManyWithoutBringerInput;
  email?: String;
  username?: String;
  password?: String;
  groups?: GroupUpdateManyWithoutMembersInput;
  invites?: InviteUpdateManyWithoutUserInput;
}

export interface EventCreateOneWithoutItemsInput {
  create?: EventCreateWithoutItemsInput;
  connect?: EventWhereUniqueInput;
}

export interface EventWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  invites_every?: InviteWhereInput;
  invites_some?: InviteWhereInput;
  invites_none?: InviteWhereInput;
  items_every?: ItemWhereInput;
  items_some?: ItemWhereInput;
  items_none?: ItemWhereInput;
  hostedBy?: UserWhereInput;
  AND?: EventWhereInput[] | EventWhereInput;
  OR?: EventWhereInput[] | EventWhereInput;
  NOT?: EventWhereInput[] | EventWhereInput;
}

export interface EventCreateWithoutItemsInput {
  location: String;
  date: DateTimeInput;
  title: String;
  description: String;
  invites?: InviteCreateManyWithoutEventInput;
  hostedBy: UserCreateOneWithoutHostingInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  items_every?: ItemWhereInput;
  items_some?: ItemWhereInput;
  items_none?: ItemWhereInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  hosting_every?: EventWhereInput;
  hosting_some?: EventWhereInput;
  hosting_none?: EventWhereInput;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  groups_every?: GroupWhereInput;
  groups_some?: GroupWhereInput;
  groups_none?: GroupWhereInput;
  invites_every?: InviteWhereInput;
  invites_some?: InviteWhereInput;
  invites_none?: InviteWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface UserCreateOneWithoutHostingInput {
  create?: UserCreateWithoutHostingInput;
  connect?: UserWhereUniqueInput;
}

export interface SignupUserPayloadSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SignupUserPayloadWhereInput;
  AND?:
    | SignupUserPayloadSubscriptionWhereInput[]
    | SignupUserPayloadSubscriptionWhereInput;
  OR?:
    | SignupUserPayloadSubscriptionWhereInput[]
    | SignupUserPayloadSubscriptionWhereInput;
  NOT?:
    | SignupUserPayloadSubscriptionWhereInput[]
    | SignupUserPayloadSubscriptionWhereInput;
}

export interface UserCreateWithoutHostingInput {
  items?: ItemCreateManyWithoutBringerInput;
  email?: String;
  username: String;
  password?: String;
  groups?: GroupCreateManyWithoutMembersInput;
  invites?: InviteCreateManyWithoutUserInput;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ItemWhereInput;
  AND?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
  OR?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
  NOT?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
}

export interface GroupCreateManyWithoutMembersInput {
  create?: GroupCreateWithoutMembersInput[] | GroupCreateWithoutMembersInput;
  connect?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
}

export interface InviteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InviteWhereInput;
  AND?: InviteSubscriptionWhereInput[] | InviteSubscriptionWhereInput;
  OR?: InviteSubscriptionWhereInput[] | InviteSubscriptionWhereInput;
  NOT?: InviteSubscriptionWhereInput[] | InviteSubscriptionWhereInput;
}

export interface GroupCreateWithoutMembersInput {
  name: String;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FileWhereInput;
  AND?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  OR?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  NOT?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
}

export interface InviteCreateManyWithoutUserInput {
  create?: InviteCreateWithoutUserInput[] | InviteCreateWithoutUserInput;
  connect?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
}

export interface AuthenticateUserPayloadSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AuthenticateUserPayloadWhereInput;
  AND?:
    | AuthenticateUserPayloadSubscriptionWhereInput[]
    | AuthenticateUserPayloadSubscriptionWhereInput;
  OR?:
    | AuthenticateUserPayloadSubscriptionWhereInput[]
    | AuthenticateUserPayloadSubscriptionWhereInput;
  NOT?:
    | AuthenticateUserPayloadSubscriptionWhereInput[]
    | AuthenticateUserPayloadSubscriptionWhereInput;
}

export interface InviteCreateWithoutUserInput {
  partySize: Int;
  response: RSVP;
  event?: EventCreateOneWithoutInvitesInput;
}

export interface UserUpdateInput {
  items?: ItemUpdateManyWithoutBringerInput;
  email?: String;
  username?: String;
  hosting?: EventUpdateManyWithoutHostedByInput;
  password?: String;
  groups?: GroupUpdateManyWithoutMembersInput;
  invites?: InviteUpdateManyWithoutUserInput;
}

export interface EventCreateOneWithoutInvitesInput {
  create?: EventCreateWithoutInvitesInput;
  connect?: EventWhereUniqueInput;
}

export type FileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  secret?: String;
  url?: String;
}>;

export interface EventCreateWithoutInvitesInput {
  location: String;
  date: DateTimeInput;
  title: String;
  description: String;
  items?: ItemCreateManyWithoutEventInput;
  hostedBy: UserCreateOneWithoutHostingInput;
}

export interface FileWhereInput {
  contentType?: String;
  contentType_not?: String;
  contentType_in?: String[] | String;
  contentType_not_in?: String[] | String;
  contentType_lt?: String;
  contentType_lte?: String;
  contentType_gt?: String;
  contentType_gte?: String;
  contentType_contains?: String;
  contentType_not_contains?: String;
  contentType_starts_with?: String;
  contentType_not_starts_with?: String;
  contentType_ends_with?: String;
  contentType_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  secret?: String;
  secret_not?: String;
  secret_in?: String[] | String;
  secret_not_in?: String[] | String;
  secret_lt?: String;
  secret_lte?: String;
  secret_gt?: String;
  secret_gte?: String;
  secret_contains?: String;
  secret_not_contains?: String;
  secret_starts_with?: String;
  secret_not_starts_with?: String;
  secret_ends_with?: String;
  secret_not_ends_with?: String;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: FileWhereInput[] | FileWhereInput;
  OR?: FileWhereInput[] | FileWhereInput;
  NOT?: FileWhereInput[] | FileWhereInput;
}

export interface ItemCreateManyWithoutEventInput {
  create?: ItemCreateWithoutEventInput[] | ItemCreateWithoutEventInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
}

export interface SignupUserPayloadCreateInput {
  token: String;
}

export interface ItemCreateWithoutEventInput {
  quantity: Int;
  name: String;
  bringer?: UserCreateOneWithoutItemsInput;
}

export interface ItemUpdateInput {
  quantity?: Int;
  name?: String;
  bringer?: UserUpdateOneWithoutItemsInput;
  event?: EventUpdateOneWithoutItemsInput;
}

export interface UserCreateOneWithoutItemsInput {
  create?: UserCreateWithoutItemsInput;
  connect?: UserWhereUniqueInput;
}

export interface ItemCreateInput {
  quantity: Int;
  name: String;
  bringer?: UserCreateOneWithoutItemsInput;
  event?: EventCreateOneWithoutItemsInput;
}

export interface UserCreateWithoutItemsInput {
  email?: String;
  username: String;
  hosting?: EventCreateManyWithoutHostedByInput;
  password?: String;
  groups?: GroupCreateManyWithoutMembersInput;
  invites?: InviteCreateManyWithoutUserInput;
}

export interface InviteUpdateInput {
  partySize?: Int;
  response?: RSVP;
  event?: EventUpdateOneWithoutInvitesInput;
  user?: UserUpdateOneWithoutInvitesInput;
}

export interface EventCreateManyWithoutHostedByInput {
  create?: EventCreateWithoutHostedByInput[] | EventCreateWithoutHostedByInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
}

export interface InviteCreateInput {
  partySize: Int;
  response: RSVP;
  event?: EventCreateOneWithoutInvitesInput;
  user?: UserCreateOneWithoutInvitesInput;
}

export interface EventCreateWithoutHostedByInput {
  location: String;
  date: DateTimeInput;
  title: String;
  description: String;
  invites?: InviteCreateManyWithoutEventInput;
  items?: ItemCreateManyWithoutEventInput;
}

export interface UserUpdateManyDataInput {
  email?: String;
  username?: String;
  password?: String;
}

export interface EventUpdateInput {
  location?: String;
  date?: DateTimeInput;
  title?: String;
  description?: String;
  invites?: InviteUpdateManyWithoutEventInput;
  items?: ItemUpdateManyWithoutEventInput;
  hostedBy?: UserUpdateOneRequiredWithoutHostingInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface InviteUpdateManyWithoutEventInput {
  create?: InviteCreateWithoutEventInput[] | InviteCreateWithoutEventInput;
  delete?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
  connect?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
  set?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
  disconnect?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
  update?:
    | InviteUpdateWithWhereUniqueWithoutEventInput[]
    | InviteUpdateWithWhereUniqueWithoutEventInput;
  upsert?:
    | InviteUpsertWithWhereUniqueWithoutEventInput[]
    | InviteUpsertWithWhereUniqueWithoutEventInput;
  deleteMany?: InviteScalarWhereInput[] | InviteScalarWhereInput;
  updateMany?:
    | InviteUpdateManyWithWhereNestedInput[]
    | InviteUpdateManyWithWhereNestedInput;
}

export interface UserUpsertWithWhereUniqueWithoutGroupsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutGroupsDataInput;
  create: UserCreateWithoutGroupsInput;
}

export interface InviteUpdateWithWhereUniqueWithoutEventInput {
  where: InviteWhereUniqueInput;
  data: InviteUpdateWithoutEventDataInput;
}

export interface UserUpdateWithoutGroupsDataInput {
  items?: ItemUpdateManyWithoutBringerInput;
  email?: String;
  username?: String;
  hosting?: EventUpdateManyWithoutHostedByInput;
  password?: String;
  invites?: InviteUpdateManyWithoutUserInput;
}

export interface InviteUpdateWithoutEventDataInput {
  partySize?: Int;
  response?: RSVP;
  user?: UserUpdateOneWithoutInvitesInput;
}

export interface UserUpdateWithWhereUniqueWithoutGroupsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutGroupsDataInput;
}

export interface UserUpdateOneWithoutInvitesInput {
  create?: UserCreateWithoutInvitesInput;
  update?: UserUpdateWithoutInvitesDataInput;
  upsert?: UserUpsertWithoutInvitesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface GroupUpdateInput {
  name?: String;
  members?: UserUpdateManyWithoutGroupsInput;
}

export interface UserUpsertWithoutHostingInput {
  update: UserUpdateWithoutHostingDataInput;
  create: UserCreateWithoutHostingInput;
}

export type SignupUserPayloadWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ItemUpdateManyWithoutBringerInput {
  create?: ItemCreateWithoutBringerInput[] | ItemCreateWithoutBringerInput;
  delete?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  set?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  disconnect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  update?:
    | ItemUpdateWithWhereUniqueWithoutBringerInput[]
    | ItemUpdateWithWhereUniqueWithoutBringerInput;
  upsert?:
    | ItemUpsertWithWhereUniqueWithoutBringerInput[]
    | ItemUpsertWithWhereUniqueWithoutBringerInput;
  deleteMany?: ItemScalarWhereInput[] | ItemScalarWhereInput;
  updateMany?:
    | ItemUpdateManyWithWhereNestedInput[]
    | ItemUpdateManyWithWhereNestedInput;
}

export interface SignupUserPayloadWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  token?: String;
  token_not?: String;
  token_in?: String[] | String;
  token_not_in?: String[] | String;
  token_lt?: String;
  token_lte?: String;
  token_gt?: String;
  token_gte?: String;
  token_contains?: String;
  token_not_contains?: String;
  token_starts_with?: String;
  token_not_starts_with?: String;
  token_ends_with?: String;
  token_not_ends_with?: String;
  AND?: SignupUserPayloadWhereInput[] | SignupUserPayloadWhereInput;
  OR?: SignupUserPayloadWhereInput[] | SignupUserPayloadWhereInput;
  NOT?: SignupUserPayloadWhereInput[] | SignupUserPayloadWhereInput;
}

export interface ItemUpdateWithWhereUniqueWithoutBringerInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutBringerDataInput;
}

export interface FileUpdateManyMutationInput {
  contentType?: String;
  name?: String;
  secret?: String;
  size?: Int;
  url?: String;
}

export interface ItemUpdateWithoutBringerDataInput {
  quantity?: Int;
  name?: String;
  event?: EventUpdateOneWithoutItemsInput;
}

export interface FileCreateInput {
  contentType: String;
  name: String;
  secret: String;
  size: Int;
  url: String;
}

export interface EventUpdateOneWithoutItemsInput {
  create?: EventCreateWithoutItemsInput;
  update?: EventUpdateWithoutItemsDataInput;
  upsert?: EventUpsertWithoutItemsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EventWhereUniqueInput;
}

export interface EventUpdateManyMutationInput {
  location?: String;
  date?: DateTimeInput;
  title?: String;
  description?: String;
}

export interface EventUpdateWithoutItemsDataInput {
  location?: String;
  date?: DateTimeInput;
  title?: String;
  description?: String;
  invites?: InviteUpdateManyWithoutEventInput;
  hostedBy?: UserUpdateOneRequiredWithoutHostingInput;
}

export interface UserUpsertWithoutInvitesInput {
  update: UserUpdateWithoutInvitesDataInput;
  create: UserCreateWithoutInvitesInput;
}

export interface UserUpdateOneRequiredWithoutHostingInput {
  create?: UserCreateWithoutHostingInput;
  update?: UserUpdateWithoutHostingDataInput;
  upsert?: UserUpsertWithoutHostingInput;
  connect?: UserWhereUniqueInput;
}

export interface AuthenticateUserPayloadCreateInput {
  token: String;
}

export interface InviteWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  partySize?: Int;
  partySize_not?: Int;
  partySize_in?: Int[] | Int;
  partySize_not_in?: Int[] | Int;
  partySize_lt?: Int;
  partySize_lte?: Int;
  partySize_gt?: Int;
  partySize_gte?: Int;
  response?: RSVP;
  response_not?: RSVP;
  response_in?: RSVP[] | RSVP;
  response_not_in?: RSVP[] | RSVP;
  event?: EventWhereInput;
  user?: UserWhereInput;
  AND?: InviteWhereInput[] | InviteWhereInput;
  OR?: InviteWhereInput[] | InviteWhereInput;
  NOT?: InviteWhereInput[] | InviteWhereInput;
}

export interface ItemUpsertWithWhereUniqueWithoutBringerInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutBringerDataInput;
  create: ItemCreateWithoutBringerInput;
}

export interface GroupUpdateManyWithoutMembersInput {
  create?: GroupCreateWithoutMembersInput[] | GroupCreateWithoutMembersInput;
  delete?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  connect?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  set?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  disconnect?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  update?:
    | GroupUpdateWithWhereUniqueWithoutMembersInput[]
    | GroupUpdateWithWhereUniqueWithoutMembersInput;
  upsert?:
    | GroupUpsertWithWhereUniqueWithoutMembersInput[]
    | GroupUpsertWithWhereUniqueWithoutMembersInput;
  deleteMany?: GroupScalarWhereInput[] | GroupScalarWhereInput;
  updateMany?:
    | GroupUpdateManyWithWhereNestedInput[]
    | GroupUpdateManyWithWhereNestedInput;
}

export interface EventCreateInput {
  location: String;
  date: DateTimeInput;
  title: String;
  description: String;
  invites?: InviteCreateManyWithoutEventInput;
  items?: ItemCreateManyWithoutEventInput;
  hostedBy: UserCreateOneWithoutHostingInput;
}

export interface GroupUpdateWithWhereUniqueWithoutMembersInput {
  where: GroupWhereUniqueInput;
  data: GroupUpdateWithoutMembersDataInput;
}

export interface InviteCreateWithoutEventInput {
  partySize: Int;
  response: RSVP;
  user?: UserCreateOneWithoutInvitesInput;
}

export interface GroupUpdateWithoutMembersDataInput {
  name?: String;
}

export interface UserCreateWithoutInvitesInput {
  items?: ItemCreateManyWithoutBringerInput;
  email?: String;
  username: String;
  hosting?: EventCreateManyWithoutHostedByInput;
  password?: String;
  groups?: GroupCreateManyWithoutMembersInput;
}

export interface GroupUpsertWithWhereUniqueWithoutMembersInput {
  where: GroupWhereUniqueInput;
  update: GroupUpdateWithoutMembersDataInput;
  create: GroupCreateWithoutMembersInput;
}

export interface ItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  quantity?: Int;
  quantity_not?: Int;
  quantity_in?: Int[] | Int;
  quantity_not_in?: Int[] | Int;
  quantity_lt?: Int;
  quantity_lte?: Int;
  quantity_gt?: Int;
  quantity_gte?: Int;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  bringer?: UserWhereInput;
  event?: EventWhereInput;
  AND?: ItemWhereInput[] | ItemWhereInput;
  OR?: ItemWhereInput[] | ItemWhereInput;
  NOT?: ItemWhereInput[] | ItemWhereInput;
}

export interface GroupScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: GroupScalarWhereInput[] | GroupScalarWhereInput;
  OR?: GroupScalarWhereInput[] | GroupScalarWhereInput;
  NOT?: GroupScalarWhereInput[] | GroupScalarWhereInput;
}

export interface LoggedInUserPayloadSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LoggedInUserPayloadWhereInput;
  AND?:
    | LoggedInUserPayloadSubscriptionWhereInput[]
    | LoggedInUserPayloadSubscriptionWhereInput;
  OR?:
    | LoggedInUserPayloadSubscriptionWhereInput[]
    | LoggedInUserPayloadSubscriptionWhereInput;
  NOT?:
    | LoggedInUserPayloadSubscriptionWhereInput[]
    | LoggedInUserPayloadSubscriptionWhereInput;
}

export interface GroupUpdateManyWithWhereNestedInput {
  where: GroupScalarWhereInput;
  data: GroupUpdateManyDataInput;
}

export interface GroupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GroupWhereInput;
  AND?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
  OR?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
  NOT?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
}

export interface GroupUpdateManyDataInput {
  name?: String;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  username?: String;
  password?: String;
}

export interface InviteUpdateManyWithoutUserInput {
  create?: InviteCreateWithoutUserInput[] | InviteCreateWithoutUserInput;
  delete?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
  connect?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
  set?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
  disconnect?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
  update?:
    | InviteUpdateWithWhereUniqueWithoutUserInput[]
    | InviteUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | InviteUpsertWithWhereUniqueWithoutUserInput[]
    | InviteUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: InviteScalarWhereInput[] | InviteScalarWhereInput;
  updateMany?:
    | InviteUpdateManyWithWhereNestedInput[]
    | InviteUpdateManyWithWhereNestedInput;
}

export interface SignupUserPayloadUpdateManyMutationInput {
  token?: String;
}

export interface InviteUpdateWithWhereUniqueWithoutUserInput {
  where: InviteWhereUniqueInput;
  data: InviteUpdateWithoutUserDataInput;
}

export interface ItemUpdateManyMutationInput {
  quantity?: Int;
  name?: String;
}

export interface InviteUpdateWithoutUserDataInput {
  partySize?: Int;
  response?: RSVP;
  event?: EventUpdateOneWithoutInvitesInput;
}

export interface InviteUpdateManyMutationInput {
  partySize?: Int;
  response?: RSVP;
}

export interface EventUpdateOneWithoutInvitesInput {
  create?: EventCreateWithoutInvitesInput;
  update?: EventUpdateWithoutInvitesDataInput;
  upsert?: EventUpsertWithoutInvitesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EventWhereUniqueInput;
}

export interface GroupUpdateManyMutationInput {
  name?: String;
}

export interface EventUpdateWithoutInvitesDataInput {
  location?: String;
  date?: DateTimeInput;
  title?: String;
  description?: String;
  items?: ItemUpdateManyWithoutEventInput;
  hostedBy?: UserUpdateOneRequiredWithoutHostingInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface ItemUpdateManyWithoutEventInput {
  create?: ItemCreateWithoutEventInput[] | ItemCreateWithoutEventInput;
  delete?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  set?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  disconnect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  update?:
    | ItemUpdateWithWhereUniqueWithoutEventInput[]
    | ItemUpdateWithWhereUniqueWithoutEventInput;
  upsert?:
    | ItemUpsertWithWhereUniqueWithoutEventInput[]
    | ItemUpsertWithWhereUniqueWithoutEventInput;
  deleteMany?: ItemScalarWhereInput[] | ItemScalarWhereInput;
  updateMany?:
    | ItemUpdateManyWithWhereNestedInput[]
    | ItemUpdateManyWithWhereNestedInput;
}

export interface LoggedInUserPayloadWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: LoggedInUserPayloadWhereInput[] | LoggedInUserPayloadWhereInput;
  OR?: LoggedInUserPayloadWhereInput[] | LoggedInUserPayloadWhereInput;
  NOT?: LoggedInUserPayloadWhereInput[] | LoggedInUserPayloadWhereInput;
}

export interface ItemUpdateWithWhereUniqueWithoutEventInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutEventDataInput;
}

export interface UserCreateWithoutGroupsInput {
  items?: ItemCreateManyWithoutBringerInput;
  email?: String;
  username: String;
  hosting?: EventCreateManyWithoutHostedByInput;
  password?: String;
  invites?: InviteCreateManyWithoutUserInput;
}

export interface ItemUpdateWithoutEventDataInput {
  quantity?: Int;
  name?: String;
  bringer?: UserUpdateOneWithoutItemsInput;
}

export interface GroupCreateInput {
  name: String;
  members?: UserCreateManyWithoutGroupsInput;
}

export interface UserUpdateOneWithoutItemsInput {
  create?: UserCreateWithoutItemsInput;
  update?: UserUpdateWithoutItemsDataInput;
  upsert?: UserUpsertWithoutItemsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface UserUpdateWithoutItemsDataInput {
  email?: String;
  username?: String;
  hosting?: EventUpdateManyWithoutHostedByInput;
  password?: String;
  groups?: GroupUpdateManyWithoutMembersInput;
  invites?: InviteUpdateManyWithoutUserInput;
}

export interface EventUpsertWithoutItemsInput {
  update: EventUpdateWithoutItemsDataInput;
  create: EventCreateWithoutItemsInput;
}

export interface EventUpdateManyWithoutHostedByInput {
  create?: EventCreateWithoutHostedByInput[] | EventCreateWithoutHostedByInput;
  delete?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  set?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  disconnect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  update?:
    | EventUpdateWithWhereUniqueWithoutHostedByInput[]
    | EventUpdateWithWhereUniqueWithoutHostedByInput;
  upsert?:
    | EventUpsertWithWhereUniqueWithoutHostedByInput[]
    | EventUpsertWithWhereUniqueWithoutHostedByInput;
  deleteMany?: EventScalarWhereInput[] | EventScalarWhereInput;
  updateMany?:
    | EventUpdateManyWithWhereNestedInput[]
    | EventUpdateManyWithWhereNestedInput;
}

export interface UserCreateOneWithoutInvitesInput {
  create?: UserCreateWithoutInvitesInput;
  connect?: UserWhereUniqueInput;
}

export interface EventUpdateWithWhereUniqueWithoutHostedByInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutHostedByDataInput;
}

export interface GroupWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  members_every?: UserWhereInput;
  members_some?: UserWhereInput;
  members_none?: UserWhereInput;
  AND?: GroupWhereInput[] | GroupWhereInput;
  OR?: GroupWhereInput[] | GroupWhereInput;
  NOT?: GroupWhereInput[] | GroupWhereInput;
}

export interface EventUpdateWithoutHostedByDataInput {
  location?: String;
  date?: DateTimeInput;
  title?: String;
  description?: String;
  invites?: InviteUpdateManyWithoutEventInput;
  items?: ItemUpdateManyWithoutEventInput;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EventWhereInput;
  AND?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  OR?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  NOT?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
}

export interface EventUpsertWithWhereUniqueWithoutHostedByInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutHostedByDataInput;
  create: EventCreateWithoutHostedByInput;
}

export interface SignupUserPayloadUpdateInput {
  token?: String;
}

export interface EventScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: EventScalarWhereInput[] | EventScalarWhereInput;
  OR?: EventScalarWhereInput[] | EventScalarWhereInput;
  NOT?: EventScalarWhereInput[] | EventScalarWhereInput;
}

export type InviteWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput;
  data: EventUpdateManyDataInput;
}

export type LoggedInUserPayloadWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface EventUpdateManyDataInput {
  location?: String;
  date?: DateTimeInput;
  title?: String;
  description?: String;
}

export interface UserCreateManyWithoutGroupsInput {
  create?: UserCreateWithoutGroupsInput[] | UserCreateWithoutGroupsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserUpsertWithoutItemsInput {
  update: UserUpdateWithoutItemsDataInput;
  create: UserCreateWithoutItemsInput;
}

export interface InviteUpsertWithWhereUniqueWithoutEventInput {
  where: InviteWhereUniqueInput;
  update: InviteUpdateWithoutEventDataInput;
  create: InviteCreateWithoutEventInput;
}

export interface ItemUpsertWithWhereUniqueWithoutEventInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutEventDataInput;
  create: ItemCreateWithoutEventInput;
}

export interface InviteCreateManyWithoutEventInput {
  create?: InviteCreateWithoutEventInput[] | InviteCreateWithoutEventInput;
  connect?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
}

export interface ItemScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  quantity?: Int;
  quantity_not?: Int;
  quantity_in?: Int[] | Int;
  quantity_not_in?: Int[] | Int;
  quantity_lt?: Int;
  quantity_lte?: Int;
  quantity_gt?: Int;
  quantity_gte?: Int;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: ItemScalarWhereInput[] | ItemScalarWhereInput;
  OR?: ItemScalarWhereInput[] | ItemScalarWhereInput;
  NOT?: ItemScalarWhereInput[] | ItemScalarWhereInput;
}

export type EventWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput;
  data: ItemUpdateManyDataInput;
}

export type GroupWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface ItemUpdateManyDataInput {
  quantity?: Int;
  name?: String;
}

export interface UserUpdateManyWithoutGroupsInput {
  create?: UserCreateWithoutGroupsInput[] | UserCreateWithoutGroupsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutGroupsInput[]
    | UserUpdateWithWhereUniqueWithoutGroupsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutGroupsInput[]
    | UserUpsertWithWhereUniqueWithoutGroupsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface InviteUpdateManyWithWhereNestedInput {
  where: InviteScalarWhereInput;
  data: InviteUpdateManyDataInput;
}

export interface InviteScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  partySize?: Int;
  partySize_not?: Int;
  partySize_in?: Int[] | Int;
  partySize_not_in?: Int[] | Int;
  partySize_lt?: Int;
  partySize_lte?: Int;
  partySize_gt?: Int;
  partySize_gte?: Int;
  response?: RSVP;
  response_not?: RSVP;
  response_in?: RSVP[] | RSVP;
  response_not_in?: RSVP[] | RSVP;
  AND?: InviteScalarWhereInput[] | InviteScalarWhereInput;
  OR?: InviteScalarWhereInput[] | InviteScalarWhereInput;
  NOT?: InviteScalarWhereInput[] | InviteScalarWhereInput;
}

export interface InviteUpsertWithWhereUniqueWithoutUserInput {
  where: InviteWhereUniqueInput;
  update: InviteUpdateWithoutUserDataInput;
  create: InviteCreateWithoutUserInput;
}

export interface EventUpsertWithoutInvitesInput {
  update: EventUpdateWithoutInvitesDataInput;
  create: EventCreateWithoutInvitesInput;
}

export interface FileUpdateInput {
  contentType?: String;
  name?: String;
  secret?: String;
  size?: Int;
  url?: String;
}

export type ItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserCreateInput {
  items?: ItemCreateManyWithoutBringerInput;
  email?: String;
  username: String;
  hosting?: EventCreateManyWithoutHostedByInput;
  password?: String;
  groups?: GroupCreateManyWithoutMembersInput;
  invites?: InviteCreateManyWithoutUserInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface AuthenticateUserPayloadUpdateManyMutationInput {
  token?: String;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email?: String;
  username: String;
  password?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface SignupUserPayloadSubscriptionPayload {
  mutation: MutationType;
  node: SignupUserPayload;
  updatedFields: String[];
  previousValues: SignupUserPayloadPreviousValues;
}

export interface SignupUserPayloadSubscriptionPayloadPromise
  extends Promise<SignupUserPayloadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SignupUserPayloadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SignupUserPayloadPreviousValuesPromise>() => T;
}

export interface SignupUserPayloadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SignupUserPayloadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SignupUserPayloadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SignupUserPayloadPreviousValuesSubscription>() => T;
}

export interface File {
  contentType: String;
  createdAt: DateTimeOutput;
  id: ID_Output;
  name: String;
  secret: String;
  size: Int;
  updatedAt: DateTimeOutput;
  url: String;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  contentType: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  secret: () => Promise<String>;
  size: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
  url: () => Promise<String>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  contentType: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  secret: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface SignupUserPayloadEdge {
  node: SignupUserPayload;
  cursor: String;
}

export interface SignupUserPayloadEdgePromise
  extends Promise<SignupUserPayloadEdge>,
    Fragmentable {
  node: <T = SignupUserPayloadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SignupUserPayloadEdgeSubscription
  extends Promise<AsyncIterator<SignupUserPayloadEdge>>,
    Fragmentable {
  node: <T = SignupUserPayloadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Event {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  location: String;
  date: DateTimeOutput;
  title: String;
  description: String;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  location: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  invites: <T = FragmentableArray<Invite>>(
    args?: {
      where?: InviteWhereInput;
      orderBy?: InviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  items: <T = FragmentableArray<Item>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hostedBy: <T = UserPromise>() => T;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  location: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  invites: <T = Promise<AsyncIterator<InviteSubscription>>>(
    args?: {
      where?: InviteWhereInput;
      orderBy?: InviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hostedBy: <T = UserSubscription>() => T;
}

export interface AuthenticateUserPayload {
  token: String;
}

export interface AuthenticateUserPayloadPromise
  extends Promise<AuthenticateUserPayload>,
    Fragmentable {
  token: () => Promise<String>;
}

export interface AuthenticateUserPayloadSubscription
  extends Promise<AsyncIterator<AuthenticateUserPayload>>,
    Fragmentable {
  token: () => Promise<AsyncIterator<String>>;
}

export interface SignupUserPayloadPreviousValues {
  id: ID_Output;
  token: String;
}

export interface SignupUserPayloadPreviousValuesPromise
  extends Promise<SignupUserPayloadPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  token: () => Promise<String>;
}

export interface SignupUserPayloadPreviousValuesSubscription
  extends Promise<AsyncIterator<SignupUserPayloadPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  token: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLoggedInUserPayload {
  count: Int;
}

export interface AggregateLoggedInUserPayloadPromise
  extends Promise<AggregateLoggedInUserPayload>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLoggedInUserPayloadSubscription
  extends Promise<AsyncIterator<AggregateLoggedInUserPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AuthenticateUserPayloadSubscriptionPayload {
  mutation: MutationType;
  node: AuthenticateUserPayload;
  updatedFields: String[];
  previousValues: AuthenticateUserPayloadPreviousValues;
}

export interface AuthenticateUserPayloadSubscriptionPayloadPromise
  extends Promise<AuthenticateUserPayloadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AuthenticateUserPayloadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AuthenticateUserPayloadPreviousValuesPromise>() => T;
}

export interface AuthenticateUserPayloadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AuthenticateUserPayloadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AuthenticateUserPayloadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = AuthenticateUserPayloadPreviousValuesSubscription
  >() => T;
}

export interface LoggedInUserPayloadConnection {
  pageInfo: PageInfo;
  edges: LoggedInUserPayloadEdge[];
}

export interface LoggedInUserPayloadConnectionPromise
  extends Promise<LoggedInUserPayloadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LoggedInUserPayloadEdge>>() => T;
  aggregate: <T = AggregateLoggedInUserPayloadPromise>() => T;
}

export interface LoggedInUserPayloadConnectionSubscription
  extends Promise<AsyncIterator<LoggedInUserPayloadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<LoggedInUserPayloadEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateLoggedInUserPayloadSubscription>() => T;
}

export interface AuthenticateUserPayloadPreviousValues {
  token: String;
}

export interface AuthenticateUserPayloadPreviousValuesPromise
  extends Promise<AuthenticateUserPayloadPreviousValues>,
    Fragmentable {
  token: () => Promise<String>;
}

export interface AuthenticateUserPayloadPreviousValuesSubscription
  extends Promise<AsyncIterator<AuthenticateUserPayloadPreviousValues>>,
    Fragmentable {
  token: () => Promise<AsyncIterator<String>>;
}

export interface LoggedInUserPayload {
  id: ID_Output;
}

export interface LoggedInUserPayloadPromise
  extends Promise<LoggedInUserPayload>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface LoggedInUserPayloadSubscription
  extends Promise<AsyncIterator<LoggedInUserPayload>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface Group {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GroupPromise extends Promise<Group>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  members: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GroupSubscription
  extends Promise<AsyncIterator<Group>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface AggregateInvite {
  count: Int;
}

export interface AggregateInvitePromise
  extends Promise<AggregateInvite>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInviteSubscription
  extends Promise<AsyncIterator<AggregateInvite>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  location: String;
  date: DateTimeOutput;
  title: String;
  description: String;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  location: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  location: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface InviteConnection {
  pageInfo: PageInfo;
  edges: InviteEdge[];
}

export interface InviteConnectionPromise
  extends Promise<InviteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InviteEdge>>() => T;
  aggregate: <T = AggregateInvitePromise>() => T;
}

export interface InviteConnectionSubscription
  extends Promise<AsyncIterator<InviteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InviteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInviteSubscription>() => T;
}

export interface AuthenticateUserPayloadEdge {
  node: AuthenticateUserPayload;
  cursor: String;
}

export interface AuthenticateUserPayloadEdgePromise
  extends Promise<AuthenticateUserPayloadEdge>,
    Fragmentable {
  node: <T = AuthenticateUserPayloadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AuthenticateUserPayloadEdgeSubscription
  extends Promise<AsyncIterator<AuthenticateUserPayloadEdge>>,
    Fragmentable {
  node: <T = AuthenticateUserPayloadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GroupEdge {
  node: Group;
  cursor: String;
}

export interface GroupEdgePromise extends Promise<GroupEdge>, Fragmentable {
  node: <T = GroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GroupEdgeSubscription
  extends Promise<AsyncIterator<GroupEdge>>,
    Fragmentable {
  node: <T = GroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FilePreviousValues {
  contentType: String;
  createdAt: DateTimeOutput;
  id: ID_Output;
  name: String;
  secret: String;
  size: Int;
  updatedAt: DateTimeOutput;
  url: String;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  contentType: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  secret: () => Promise<String>;
  size: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
  url: () => Promise<String>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  contentType: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  secret: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface AggregateAuthenticateUserPayload {
  count: Int;
}

export interface AggregateAuthenticateUserPayloadPromise
  extends Promise<AggregateAuthenticateUserPayload>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAuthenticateUserPayloadSubscription
  extends Promise<AsyncIterator<AggregateAuthenticateUserPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GroupSubscriptionPayload {
  mutation: MutationType;
  node: Group;
  updatedFields: String[];
  previousValues: GroupPreviousValues;
}

export interface GroupSubscriptionPayloadPromise
  extends Promise<GroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GroupPreviousValuesPromise>() => T;
}

export interface GroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GroupPreviousValuesSubscription>() => T;
}

export interface SignupUserPayloadConnection {
  pageInfo: PageInfo;
  edges: SignupUserPayloadEdge[];
}

export interface SignupUserPayloadConnectionPromise
  extends Promise<SignupUserPayloadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SignupUserPayloadEdge>>() => T;
  aggregate: <T = AggregateSignupUserPayloadPromise>() => T;
}

export interface SignupUserPayloadConnectionSubscription
  extends Promise<AsyncIterator<SignupUserPayloadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SignupUserPayloadEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSignupUserPayloadSubscription>() => T;
}

export interface GroupPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GroupPreviousValuesPromise
  extends Promise<GroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GroupPreviousValuesSubscription
  extends Promise<AsyncIterator<GroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LoggedInUserPayloadEdge {
  node: LoggedInUserPayload;
  cursor: String;
}

export interface LoggedInUserPayloadEdgePromise
  extends Promise<LoggedInUserPayloadEdge>,
    Fragmentable {
  node: <T = LoggedInUserPayloadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LoggedInUserPayloadEdgeSubscription
  extends Promise<AsyncIterator<LoggedInUserPayloadEdge>>,
    Fragmentable {
  node: <T = LoggedInUserPayloadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Item {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  quantity: Int;
  name: String;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  quantity: () => Promise<Int>;
  name: () => Promise<String>;
  bringer: <T = UserPromise>() => T;
  event: <T = EventPromise>() => T;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  bringer: <T = UserSubscription>() => T;
  event: <T = EventSubscription>() => T;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InviteSubscriptionPayload {
  mutation: MutationType;
  node: Invite;
  updatedFields: String[];
  previousValues: InvitePreviousValues;
}

export interface InviteSubscriptionPayloadPromise
  extends Promise<InviteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InvitePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InvitePreviousValuesPromise>() => T;
}

export interface InviteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InviteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InviteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InvitePreviousValuesSubscription>() => T;
}

export interface InviteEdge {
  node: Invite;
  cursor: String;
}

export interface InviteEdgePromise extends Promise<InviteEdge>, Fragmentable {
  node: <T = InvitePromise>() => T;
  cursor: () => Promise<String>;
}

export interface InviteEdgeSubscription
  extends Promise<AsyncIterator<InviteEdge>>,
    Fragmentable {
  node: <T = InviteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InvitePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  partySize: Int;
  response: RSVP;
}

export interface InvitePreviousValuesPromise
  extends Promise<InvitePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  partySize: () => Promise<Int>;
  response: () => Promise<RSVP>;
}

export interface InvitePreviousValuesSubscription
  extends Promise<AsyncIterator<InvitePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  partySize: () => Promise<AsyncIterator<Int>>;
  response: () => Promise<AsyncIterator<RSVP>>;
}

export interface GroupConnection {
  pageInfo: PageInfo;
  edges: GroupEdge[];
}

export interface GroupConnectionPromise
  extends Promise<GroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GroupEdge>>() => T;
  aggregate: <T = AggregateGroupPromise>() => T;
}

export interface GroupConnectionSubscription
  extends Promise<AsyncIterator<GroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGroupSubscription>() => T;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email?: String;
  username: String;
  password?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  items: <T = FragmentableArray<Item>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  email: () => Promise<String>;
  username: () => Promise<String>;
  hosting: <T = FragmentableArray<Event>>(
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  password: () => Promise<String>;
  groups: <T = FragmentableArray<Group>>(
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  invites: <T = FragmentableArray<Invite>>(
    args?: {
      where?: InviteWhereInput;
      orderBy?: InviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  hosting: <T = Promise<AsyncIterator<EventSubscription>>>(
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  password: () => Promise<AsyncIterator<String>>;
  groups: <T = Promise<AsyncIterator<GroupSubscription>>>(
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  invites: <T = Promise<AsyncIterator<InviteSubscription>>>(
    args?: {
      where?: InviteWhereInput;
      orderBy?: InviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface SignupUserPayload {
  id: ID_Output;
  token: String;
}

export interface SignupUserPayloadPromise
  extends Promise<SignupUserPayload>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  token: () => Promise<String>;
}

export interface SignupUserPayloadSubscription
  extends Promise<AsyncIterator<SignupUserPayload>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  token: () => Promise<AsyncIterator<String>>;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface LoggedInUserPayloadPreviousValues {
  id: ID_Output;
}

export interface LoggedInUserPayloadPreviousValuesPromise
  extends Promise<LoggedInUserPayloadPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface LoggedInUserPayloadPreviousValuesSubscription
  extends Promise<AsyncIterator<LoggedInUserPayloadPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface LoggedInUserPayloadSubscriptionPayload {
  mutation: MutationType;
  node: LoggedInUserPayload;
  updatedFields: String[];
  previousValues: LoggedInUserPayloadPreviousValues;
}

export interface LoggedInUserPayloadSubscriptionPayloadPromise
  extends Promise<LoggedInUserPayloadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LoggedInUserPayloadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LoggedInUserPayloadPreviousValuesPromise>() => T;
}

export interface LoggedInUserPayloadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LoggedInUserPayloadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LoggedInUserPayloadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LoggedInUserPayloadPreviousValuesSubscription>() => T;
}

export interface Invite {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  partySize: Int;
  response: RSVP;
}

export interface InvitePromise extends Promise<Invite>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  partySize: () => Promise<Int>;
  response: () => Promise<RSVP>;
  event: <T = EventPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface InviteSubscription
  extends Promise<AsyncIterator<Invite>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  partySize: () => Promise<AsyncIterator<Int>>;
  response: () => Promise<AsyncIterator<RSVP>>;
  event: <T = EventSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface ItemPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  quantity: Int;
  name: String;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  quantity: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGroup {
  count: Int;
}

export interface AggregateGroupPromise
  extends Promise<AggregateGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGroupSubscription
  extends Promise<AsyncIterator<AggregateGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AuthenticateUserPayloadConnection {
  pageInfo: PageInfo;
  edges: AuthenticateUserPayloadEdge[];
}

export interface AuthenticateUserPayloadConnectionPromise
  extends Promise<AuthenticateUserPayloadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AuthenticateUserPayloadEdge>>() => T;
  aggregate: <T = AggregateAuthenticateUserPayloadPromise>() => T;
}

export interface AuthenticateUserPayloadConnectionSubscription
  extends Promise<AsyncIterator<AuthenticateUserPayloadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<AuthenticateUserPayloadEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateAuthenticateUserPayloadSubscription>() => T;
}

export interface AggregateSignupUserPayload {
  count: Int;
}

export interface AggregateSignupUserPayloadPromise
  extends Promise<AggregateSignupUserPayload>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSignupUserPayloadSubscription
  extends Promise<AsyncIterator<AggregateSignupUserPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "AuthenticateUserPayload",
    embedded: false
  },
  {
    name: "LoggedInUserPayload",
    embedded: false
  },
  {
    name: "SignupUserPayload",
    embedded: false
  },
  {
    name: "RSVP",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Invite",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  },
  {
    name: "Group",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
