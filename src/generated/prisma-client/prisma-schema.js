module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.30.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateAuthenticateUserPayload {
  count: Int!
}

type AggregateEvent {
  count: Int!
}

type AggregateFile {
  count: Int!
}

type AggregateGroup {
  count: Int!
}

type AggregateInvite {
  count: Int!
}

type AggregateItem {
  count: Int!
}

type AggregateLoggedInUserPayload {
  count: Int!
}

type AggregateSignupUserPayload {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AuthenticateUserPayload {
  token: String!
}

type AuthenticateUserPayloadConnection {
  pageInfo: PageInfo!
  edges: [AuthenticateUserPayloadEdge]!
  aggregate: AggregateAuthenticateUserPayload!
}

input AuthenticateUserPayloadCreateInput {
  token: String!
}

type AuthenticateUserPayloadEdge {
  node: AuthenticateUserPayload!
  cursor: String!
}

enum AuthenticateUserPayloadOrderByInput {
  token_ASC
  token_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AuthenticateUserPayloadPreviousValues {
  token: String!
}

type AuthenticateUserPayloadSubscriptionPayload {
  mutation: MutationType!
  node: AuthenticateUserPayload
  updatedFields: [String!]
  previousValues: AuthenticateUserPayloadPreviousValues
}

input AuthenticateUserPayloadSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AuthenticateUserPayloadWhereInput
  AND: [AuthenticateUserPayloadSubscriptionWhereInput!]
  OR: [AuthenticateUserPayloadSubscriptionWhereInput!]
  NOT: [AuthenticateUserPayloadSubscriptionWhereInput!]
}

input AuthenticateUserPayloadUpdateManyMutationInput {
  token: String
}

input AuthenticateUserPayloadWhereInput {
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_lt: String
  token_lte: String
  token_gt: String
  token_gte: String
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  AND: [AuthenticateUserPayloadWhereInput!]
  OR: [AuthenticateUserPayloadWhereInput!]
  NOT: [AuthenticateUserPayloadWhereInput!]
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Event {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  location: String!
  date: DateTime!
  title: String!
  description: String!
  invites(where: InviteWhereInput, orderBy: InviteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Invite!]
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
  hostedBy: User!
}

type EventConnection {
  pageInfo: PageInfo!
  edges: [EventEdge]!
  aggregate: AggregateEvent!
}

input EventCreateInput {
  location: String!
  date: DateTime!
  title: String!
  description: String!
  invites: InviteCreateManyWithoutEventInput
  items: ItemCreateManyWithoutEventInput
  hostedBy: UserCreateOneWithoutHostingInput!
}

input EventCreateManyWithoutHostedByInput {
  create: [EventCreateWithoutHostedByInput!]
  connect: [EventWhereUniqueInput!]
}

input EventCreateOneWithoutInvitesInput {
  create: EventCreateWithoutInvitesInput
  connect: EventWhereUniqueInput
}

input EventCreateOneWithoutItemsInput {
  create: EventCreateWithoutItemsInput
  connect: EventWhereUniqueInput
}

input EventCreateWithoutHostedByInput {
  location: String!
  date: DateTime!
  title: String!
  description: String!
  invites: InviteCreateManyWithoutEventInput
  items: ItemCreateManyWithoutEventInput
}

input EventCreateWithoutInvitesInput {
  location: String!
  date: DateTime!
  title: String!
  description: String!
  items: ItemCreateManyWithoutEventInput
  hostedBy: UserCreateOneWithoutHostingInput!
}

input EventCreateWithoutItemsInput {
  location: String!
  date: DateTime!
  title: String!
  description: String!
  invites: InviteCreateManyWithoutEventInput
  hostedBy: UserCreateOneWithoutHostingInput!
}

type EventEdge {
  node: Event!
  cursor: String!
}

enum EventOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  location_ASC
  location_DESC
  date_ASC
  date_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
}

type EventPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  location: String!
  date: DateTime!
  title: String!
  description: String!
}

input EventScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [EventScalarWhereInput!]
  OR: [EventScalarWhereInput!]
  NOT: [EventScalarWhereInput!]
}

type EventSubscriptionPayload {
  mutation: MutationType!
  node: Event
  updatedFields: [String!]
  previousValues: EventPreviousValues
}

input EventSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EventWhereInput
  AND: [EventSubscriptionWhereInput!]
  OR: [EventSubscriptionWhereInput!]
  NOT: [EventSubscriptionWhereInput!]
}

input EventUpdateInput {
  location: String
  date: DateTime
  title: String
  description: String
  invites: InviteUpdateManyWithoutEventInput
  items: ItemUpdateManyWithoutEventInput
  hostedBy: UserUpdateOneRequiredWithoutHostingInput
}

input EventUpdateManyDataInput {
  location: String
  date: DateTime
  title: String
  description: String
}

input EventUpdateManyMutationInput {
  location: String
  date: DateTime
  title: String
  description: String
}

input EventUpdateManyWithoutHostedByInput {
  create: [EventCreateWithoutHostedByInput!]
  delete: [EventWhereUniqueInput!]
  connect: [EventWhereUniqueInput!]
  set: [EventWhereUniqueInput!]
  disconnect: [EventWhereUniqueInput!]
  update: [EventUpdateWithWhereUniqueWithoutHostedByInput!]
  upsert: [EventUpsertWithWhereUniqueWithoutHostedByInput!]
  deleteMany: [EventScalarWhereInput!]
  updateMany: [EventUpdateManyWithWhereNestedInput!]
}

input EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput!
  data: EventUpdateManyDataInput!
}

input EventUpdateOneWithoutInvitesInput {
  create: EventCreateWithoutInvitesInput
  update: EventUpdateWithoutInvitesDataInput
  upsert: EventUpsertWithoutInvitesInput
  delete: Boolean
  disconnect: Boolean
  connect: EventWhereUniqueInput
}

input EventUpdateOneWithoutItemsInput {
  create: EventCreateWithoutItemsInput
  update: EventUpdateWithoutItemsDataInput
  upsert: EventUpsertWithoutItemsInput
  delete: Boolean
  disconnect: Boolean
  connect: EventWhereUniqueInput
}

input EventUpdateWithoutHostedByDataInput {
  location: String
  date: DateTime
  title: String
  description: String
  invites: InviteUpdateManyWithoutEventInput
  items: ItemUpdateManyWithoutEventInput
}

input EventUpdateWithoutInvitesDataInput {
  location: String
  date: DateTime
  title: String
  description: String
  items: ItemUpdateManyWithoutEventInput
  hostedBy: UserUpdateOneRequiredWithoutHostingInput
}

input EventUpdateWithoutItemsDataInput {
  location: String
  date: DateTime
  title: String
  description: String
  invites: InviteUpdateManyWithoutEventInput
  hostedBy: UserUpdateOneRequiredWithoutHostingInput
}

input EventUpdateWithWhereUniqueWithoutHostedByInput {
  where: EventWhereUniqueInput!
  data: EventUpdateWithoutHostedByDataInput!
}

input EventUpsertWithoutInvitesInput {
  update: EventUpdateWithoutInvitesDataInput!
  create: EventCreateWithoutInvitesInput!
}

input EventUpsertWithoutItemsInput {
  update: EventUpdateWithoutItemsDataInput!
  create: EventCreateWithoutItemsInput!
}

input EventUpsertWithWhereUniqueWithoutHostedByInput {
  where: EventWhereUniqueInput!
  update: EventUpdateWithoutHostedByDataInput!
  create: EventCreateWithoutHostedByInput!
}

input EventWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  invites_every: InviteWhereInput
  invites_some: InviteWhereInput
  invites_none: InviteWhereInput
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  hostedBy: UserWhereInput
  AND: [EventWhereInput!]
  OR: [EventWhereInput!]
  NOT: [EventWhereInput!]
}

input EventWhereUniqueInput {
  id: ID
}

type File {
  contentType: String!
  createdAt: DateTime!
  id: ID!
  name: String!
  secret: String!
  size: Int!
  updatedAt: DateTime!
  url: String!
}

type FileConnection {
  pageInfo: PageInfo!
  edges: [FileEdge]!
  aggregate: AggregateFile!
}

input FileCreateInput {
  contentType: String!
  name: String!
  secret: String!
  size: Int!
  url: String!
}

type FileEdge {
  node: File!
  cursor: String!
}

enum FileOrderByInput {
  contentType_ASC
  contentType_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  secret_ASC
  secret_DESC
  size_ASC
  size_DESC
  updatedAt_ASC
  updatedAt_DESC
  url_ASC
  url_DESC
}

type FilePreviousValues {
  contentType: String!
  createdAt: DateTime!
  id: ID!
  name: String!
  secret: String!
  size: Int!
  updatedAt: DateTime!
  url: String!
}

type FileSubscriptionPayload {
  mutation: MutationType!
  node: File
  updatedFields: [String!]
  previousValues: FilePreviousValues
}

input FileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FileWhereInput
  AND: [FileSubscriptionWhereInput!]
  OR: [FileSubscriptionWhereInput!]
  NOT: [FileSubscriptionWhereInput!]
}

input FileUpdateInput {
  contentType: String
  name: String
  secret: String
  size: Int
  url: String
}

input FileUpdateManyMutationInput {
  contentType: String
  name: String
  secret: String
  size: Int
  url: String
}

input FileWhereInput {
  contentType: String
  contentType_not: String
  contentType_in: [String!]
  contentType_not_in: [String!]
  contentType_lt: String
  contentType_lte: String
  contentType_gt: String
  contentType_gte: String
  contentType_contains: String
  contentType_not_contains: String
  contentType_starts_with: String
  contentType_not_starts_with: String
  contentType_ends_with: String
  contentType_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  secret: String
  secret_not: String
  secret_in: [String!]
  secret_not_in: [String!]
  secret_lt: String
  secret_lte: String
  secret_gt: String
  secret_gte: String
  secret_contains: String
  secret_not_contains: String
  secret_starts_with: String
  secret_not_starts_with: String
  secret_ends_with: String
  secret_not_ends_with: String
  size: Int
  size_not: Int
  size_in: [Int!]
  size_not_in: [Int!]
  size_lt: Int
  size_lte: Int
  size_gt: Int
  size_gte: Int
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [FileWhereInput!]
  OR: [FileWhereInput!]
  NOT: [FileWhereInput!]
}

input FileWhereUniqueInput {
  id: ID
  secret: String
  url: String
}

type Group {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  members(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
}

type GroupConnection {
  pageInfo: PageInfo!
  edges: [GroupEdge]!
  aggregate: AggregateGroup!
}

input GroupCreateInput {
  name: String!
  members: UserCreateManyWithoutGroupsInput
}

input GroupCreateManyWithoutMembersInput {
  create: [GroupCreateWithoutMembersInput!]
  connect: [GroupWhereUniqueInput!]
}

input GroupCreateWithoutMembersInput {
  name: String!
}

type GroupEdge {
  node: Group!
  cursor: String!
}

enum GroupOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GroupPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input GroupScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [GroupScalarWhereInput!]
  OR: [GroupScalarWhereInput!]
  NOT: [GroupScalarWhereInput!]
}

type GroupSubscriptionPayload {
  mutation: MutationType!
  node: Group
  updatedFields: [String!]
  previousValues: GroupPreviousValues
}

input GroupSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GroupWhereInput
  AND: [GroupSubscriptionWhereInput!]
  OR: [GroupSubscriptionWhereInput!]
  NOT: [GroupSubscriptionWhereInput!]
}

input GroupUpdateInput {
  name: String
  members: UserUpdateManyWithoutGroupsInput
}

input GroupUpdateManyDataInput {
  name: String
}

input GroupUpdateManyMutationInput {
  name: String
}

input GroupUpdateManyWithoutMembersInput {
  create: [GroupCreateWithoutMembersInput!]
  delete: [GroupWhereUniqueInput!]
  connect: [GroupWhereUniqueInput!]
  set: [GroupWhereUniqueInput!]
  disconnect: [GroupWhereUniqueInput!]
  update: [GroupUpdateWithWhereUniqueWithoutMembersInput!]
  upsert: [GroupUpsertWithWhereUniqueWithoutMembersInput!]
  deleteMany: [GroupScalarWhereInput!]
  updateMany: [GroupUpdateManyWithWhereNestedInput!]
}

input GroupUpdateManyWithWhereNestedInput {
  where: GroupScalarWhereInput!
  data: GroupUpdateManyDataInput!
}

input GroupUpdateWithoutMembersDataInput {
  name: String
}

input GroupUpdateWithWhereUniqueWithoutMembersInput {
  where: GroupWhereUniqueInput!
  data: GroupUpdateWithoutMembersDataInput!
}

input GroupUpsertWithWhereUniqueWithoutMembersInput {
  where: GroupWhereUniqueInput!
  update: GroupUpdateWithoutMembersDataInput!
  create: GroupCreateWithoutMembersInput!
}

input GroupWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  members_every: UserWhereInput
  members_some: UserWhereInput
  members_none: UserWhereInput
  AND: [GroupWhereInput!]
  OR: [GroupWhereInput!]
  NOT: [GroupWhereInput!]
}

input GroupWhereUniqueInput {
  id: ID
  name: String
}

type Invite {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  partySize: Int!
  response: RSVP!
  event: Event
  user: User
}

type InviteConnection {
  pageInfo: PageInfo!
  edges: [InviteEdge]!
  aggregate: AggregateInvite!
}

input InviteCreateInput {
  partySize: Int!
  response: RSVP!
  event: EventCreateOneWithoutInvitesInput
  user: UserCreateOneWithoutInvitesInput
}

input InviteCreateManyWithoutEventInput {
  create: [InviteCreateWithoutEventInput!]
  connect: [InviteWhereUniqueInput!]
}

input InviteCreateManyWithoutUserInput {
  create: [InviteCreateWithoutUserInput!]
  connect: [InviteWhereUniqueInput!]
}

input InviteCreateWithoutEventInput {
  partySize: Int!
  response: RSVP!
  user: UserCreateOneWithoutInvitesInput
}

input InviteCreateWithoutUserInput {
  partySize: Int!
  response: RSVP!
  event: EventCreateOneWithoutInvitesInput
}

type InviteEdge {
  node: Invite!
  cursor: String!
}

enum InviteOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  partySize_ASC
  partySize_DESC
  response_ASC
  response_DESC
}

type InvitePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  partySize: Int!
  response: RSVP!
}

input InviteScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  partySize: Int
  partySize_not: Int
  partySize_in: [Int!]
  partySize_not_in: [Int!]
  partySize_lt: Int
  partySize_lte: Int
  partySize_gt: Int
  partySize_gte: Int
  response: RSVP
  response_not: RSVP
  response_in: [RSVP!]
  response_not_in: [RSVP!]
  AND: [InviteScalarWhereInput!]
  OR: [InviteScalarWhereInput!]
  NOT: [InviteScalarWhereInput!]
}

type InviteSubscriptionPayload {
  mutation: MutationType!
  node: Invite
  updatedFields: [String!]
  previousValues: InvitePreviousValues
}

input InviteSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InviteWhereInput
  AND: [InviteSubscriptionWhereInput!]
  OR: [InviteSubscriptionWhereInput!]
  NOT: [InviteSubscriptionWhereInput!]
}

input InviteUpdateInput {
  partySize: Int
  response: RSVP
  event: EventUpdateOneWithoutInvitesInput
  user: UserUpdateOneWithoutInvitesInput
}

input InviteUpdateManyDataInput {
  partySize: Int
  response: RSVP
}

input InviteUpdateManyMutationInput {
  partySize: Int
  response: RSVP
}

input InviteUpdateManyWithoutEventInput {
  create: [InviteCreateWithoutEventInput!]
  delete: [InviteWhereUniqueInput!]
  connect: [InviteWhereUniqueInput!]
  set: [InviteWhereUniqueInput!]
  disconnect: [InviteWhereUniqueInput!]
  update: [InviteUpdateWithWhereUniqueWithoutEventInput!]
  upsert: [InviteUpsertWithWhereUniqueWithoutEventInput!]
  deleteMany: [InviteScalarWhereInput!]
  updateMany: [InviteUpdateManyWithWhereNestedInput!]
}

input InviteUpdateManyWithoutUserInput {
  create: [InviteCreateWithoutUserInput!]
  delete: [InviteWhereUniqueInput!]
  connect: [InviteWhereUniqueInput!]
  set: [InviteWhereUniqueInput!]
  disconnect: [InviteWhereUniqueInput!]
  update: [InviteUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [InviteUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [InviteScalarWhereInput!]
  updateMany: [InviteUpdateManyWithWhereNestedInput!]
}

input InviteUpdateManyWithWhereNestedInput {
  where: InviteScalarWhereInput!
  data: InviteUpdateManyDataInput!
}

input InviteUpdateWithoutEventDataInput {
  partySize: Int
  response: RSVP
  user: UserUpdateOneWithoutInvitesInput
}

input InviteUpdateWithoutUserDataInput {
  partySize: Int
  response: RSVP
  event: EventUpdateOneWithoutInvitesInput
}

input InviteUpdateWithWhereUniqueWithoutEventInput {
  where: InviteWhereUniqueInput!
  data: InviteUpdateWithoutEventDataInput!
}

input InviteUpdateWithWhereUniqueWithoutUserInput {
  where: InviteWhereUniqueInput!
  data: InviteUpdateWithoutUserDataInput!
}

input InviteUpsertWithWhereUniqueWithoutEventInput {
  where: InviteWhereUniqueInput!
  update: InviteUpdateWithoutEventDataInput!
  create: InviteCreateWithoutEventInput!
}

input InviteUpsertWithWhereUniqueWithoutUserInput {
  where: InviteWhereUniqueInput!
  update: InviteUpdateWithoutUserDataInput!
  create: InviteCreateWithoutUserInput!
}

input InviteWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  partySize: Int
  partySize_not: Int
  partySize_in: [Int!]
  partySize_not_in: [Int!]
  partySize_lt: Int
  partySize_lte: Int
  partySize_gt: Int
  partySize_gte: Int
  response: RSVP
  response_not: RSVP
  response_in: [RSVP!]
  response_not_in: [RSVP!]
  event: EventWhereInput
  user: UserWhereInput
  AND: [InviteWhereInput!]
  OR: [InviteWhereInput!]
  NOT: [InviteWhereInput!]
}

input InviteWhereUniqueInput {
  id: ID
}

type Item {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  quantity: Int!
  name: String!
  bringer: User
  event: Event
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  quantity: Int!
  name: String!
  bringer: UserCreateOneWithoutItemsInput
  event: EventCreateOneWithoutItemsInput
}

input ItemCreateManyWithoutBringerInput {
  create: [ItemCreateWithoutBringerInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateManyWithoutEventInput {
  create: [ItemCreateWithoutEventInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateWithoutBringerInput {
  quantity: Int!
  name: String!
  event: EventCreateOneWithoutItemsInput
}

input ItemCreateWithoutEventInput {
  quantity: Int!
  name: String!
  bringer: UserCreateOneWithoutItemsInput
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  quantity_ASC
  quantity_DESC
  name_ASC
  name_DESC
}

type ItemPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  quantity: Int!
  name: String!
}

input ItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

input ItemUpdateInput {
  quantity: Int
  name: String
  bringer: UserUpdateOneWithoutItemsInput
  event: EventUpdateOneWithoutItemsInput
}

input ItemUpdateManyDataInput {
  quantity: Int
  name: String
}

input ItemUpdateManyMutationInput {
  quantity: Int
  name: String
}

input ItemUpdateManyWithoutBringerInput {
  create: [ItemCreateWithoutBringerInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutBringerInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutBringerInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithoutEventInput {
  create: [ItemCreateWithoutEventInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutEventInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutEventInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput!
  data: ItemUpdateManyDataInput!
}

input ItemUpdateWithoutBringerDataInput {
  quantity: Int
  name: String
  event: EventUpdateOneWithoutItemsInput
}

input ItemUpdateWithoutEventDataInput {
  quantity: Int
  name: String
  bringer: UserUpdateOneWithoutItemsInput
}

input ItemUpdateWithWhereUniqueWithoutBringerInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutBringerDataInput!
}

input ItemUpdateWithWhereUniqueWithoutEventInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutEventDataInput!
}

input ItemUpsertWithWhereUniqueWithoutBringerInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutBringerDataInput!
  create: ItemCreateWithoutBringerInput!
}

input ItemUpsertWithWhereUniqueWithoutEventInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutEventDataInput!
  create: ItemCreateWithoutEventInput!
}

input ItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  bringer: UserWhereInput
  event: EventWhereInput
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: ID
}

type LoggedInUserPayload {
  id: ID!
}

type LoggedInUserPayloadConnection {
  pageInfo: PageInfo!
  edges: [LoggedInUserPayloadEdge]!
  aggregate: AggregateLoggedInUserPayload!
}

type LoggedInUserPayloadEdge {
  node: LoggedInUserPayload!
  cursor: String!
}

enum LoggedInUserPayloadOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LoggedInUserPayloadPreviousValues {
  id: ID!
}

type LoggedInUserPayloadSubscriptionPayload {
  mutation: MutationType!
  node: LoggedInUserPayload
  updatedFields: [String!]
  previousValues: LoggedInUserPayloadPreviousValues
}

input LoggedInUserPayloadSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LoggedInUserPayloadWhereInput
  AND: [LoggedInUserPayloadSubscriptionWhereInput!]
  OR: [LoggedInUserPayloadSubscriptionWhereInput!]
  NOT: [LoggedInUserPayloadSubscriptionWhereInput!]
}

input LoggedInUserPayloadWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [LoggedInUserPayloadWhereInput!]
  OR: [LoggedInUserPayloadWhereInput!]
  NOT: [LoggedInUserPayloadWhereInput!]
}

input LoggedInUserPayloadWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAuthenticateUserPayload(data: AuthenticateUserPayloadCreateInput!): AuthenticateUserPayload!
  updateManyAuthenticateUserPayloads(data: AuthenticateUserPayloadUpdateManyMutationInput!, where: AuthenticateUserPayloadWhereInput): BatchPayload!
  deleteManyAuthenticateUserPayloads(where: AuthenticateUserPayloadWhereInput): BatchPayload!
  createEvent(data: EventCreateInput!): Event!
  updateEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
  updateManyEvents(data: EventUpdateManyMutationInput!, where: EventWhereInput): BatchPayload!
  upsertEvent(where: EventWhereUniqueInput!, create: EventCreateInput!, update: EventUpdateInput!): Event!
  deleteEvent(where: EventWhereUniqueInput!): Event
  deleteManyEvents(where: EventWhereInput): BatchPayload!
  createFile(data: FileCreateInput!): File!
  updateFile(data: FileUpdateInput!, where: FileWhereUniqueInput!): File
  updateManyFiles(data: FileUpdateManyMutationInput!, where: FileWhereInput): BatchPayload!
  upsertFile(where: FileWhereUniqueInput!, create: FileCreateInput!, update: FileUpdateInput!): File!
  deleteFile(where: FileWhereUniqueInput!): File
  deleteManyFiles(where: FileWhereInput): BatchPayload!
  createGroup(data: GroupCreateInput!): Group!
  updateGroup(data: GroupUpdateInput!, where: GroupWhereUniqueInput!): Group
  updateManyGroups(data: GroupUpdateManyMutationInput!, where: GroupWhereInput): BatchPayload!
  upsertGroup(where: GroupWhereUniqueInput!, create: GroupCreateInput!, update: GroupUpdateInput!): Group!
  deleteGroup(where: GroupWhereUniqueInput!): Group
  deleteManyGroups(where: GroupWhereInput): BatchPayload!
  createInvite(data: InviteCreateInput!): Invite!
  updateInvite(data: InviteUpdateInput!, where: InviteWhereUniqueInput!): Invite
  updateManyInvites(data: InviteUpdateManyMutationInput!, where: InviteWhereInput): BatchPayload!
  upsertInvite(where: InviteWhereUniqueInput!, create: InviteCreateInput!, update: InviteUpdateInput!): Invite!
  deleteInvite(where: InviteWhereUniqueInput!): Invite
  deleteManyInvites(where: InviteWhereInput): BatchPayload!
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  createLoggedInUserPayload: LoggedInUserPayload!
  deleteLoggedInUserPayload(where: LoggedInUserPayloadWhereUniqueInput!): LoggedInUserPayload
  deleteManyLoggedInUserPayloads(where: LoggedInUserPayloadWhereInput): BatchPayload!
  createSignupUserPayload(data: SignupUserPayloadCreateInput!): SignupUserPayload!
  updateSignupUserPayload(data: SignupUserPayloadUpdateInput!, where: SignupUserPayloadWhereUniqueInput!): SignupUserPayload
  updateManySignupUserPayloads(data: SignupUserPayloadUpdateManyMutationInput!, where: SignupUserPayloadWhereInput): BatchPayload!
  upsertSignupUserPayload(where: SignupUserPayloadWhereUniqueInput!, create: SignupUserPayloadCreateInput!, update: SignupUserPayloadUpdateInput!): SignupUserPayload!
  deleteSignupUserPayload(where: SignupUserPayloadWhereUniqueInput!): SignupUserPayload
  deleteManySignupUserPayloads(where: SignupUserPayloadWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  authenticateUserPayloads(where: AuthenticateUserPayloadWhereInput, orderBy: AuthenticateUserPayloadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AuthenticateUserPayload]!
  authenticateUserPayloadsConnection(where: AuthenticateUserPayloadWhereInput, orderBy: AuthenticateUserPayloadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AuthenticateUserPayloadConnection!
  event(where: EventWhereUniqueInput!): Event
  events(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event]!
  eventsConnection(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EventConnection!
  file(where: FileWhereUniqueInput!): File
  files(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [File]!
  filesConnection(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FileConnection!
  group(where: GroupWhereUniqueInput!): Group
  groups(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Group]!
  groupsConnection(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GroupConnection!
  invite(where: InviteWhereUniqueInput!): Invite
  invites(where: InviteWhereInput, orderBy: InviteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Invite]!
  invitesConnection(where: InviteWhereInput, orderBy: InviteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InviteConnection!
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  loggedInUserPayload(where: LoggedInUserPayloadWhereUniqueInput!): LoggedInUserPayload
  loggedInUserPayloads(where: LoggedInUserPayloadWhereInput, orderBy: LoggedInUserPayloadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LoggedInUserPayload]!
  loggedInUserPayloadsConnection(where: LoggedInUserPayloadWhereInput, orderBy: LoggedInUserPayloadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LoggedInUserPayloadConnection!
  signupUserPayload(where: SignupUserPayloadWhereUniqueInput!): SignupUserPayload
  signupUserPayloads(where: SignupUserPayloadWhereInput, orderBy: SignupUserPayloadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SignupUserPayload]!
  signupUserPayloadsConnection(where: SignupUserPayloadWhereInput, orderBy: SignupUserPayloadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SignupUserPayloadConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum RSVP {
  Yes
  No
  Maybe
}

type SignupUserPayload {
  id: ID!
  token: String!
}

type SignupUserPayloadConnection {
  pageInfo: PageInfo!
  edges: [SignupUserPayloadEdge]!
  aggregate: AggregateSignupUserPayload!
}

input SignupUserPayloadCreateInput {
  token: String!
}

type SignupUserPayloadEdge {
  node: SignupUserPayload!
  cursor: String!
}

enum SignupUserPayloadOrderByInput {
  id_ASC
  id_DESC
  token_ASC
  token_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SignupUserPayloadPreviousValues {
  id: ID!
  token: String!
}

type SignupUserPayloadSubscriptionPayload {
  mutation: MutationType!
  node: SignupUserPayload
  updatedFields: [String!]
  previousValues: SignupUserPayloadPreviousValues
}

input SignupUserPayloadSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SignupUserPayloadWhereInput
  AND: [SignupUserPayloadSubscriptionWhereInput!]
  OR: [SignupUserPayloadSubscriptionWhereInput!]
  NOT: [SignupUserPayloadSubscriptionWhereInput!]
}

input SignupUserPayloadUpdateInput {
  token: String
}

input SignupUserPayloadUpdateManyMutationInput {
  token: String
}

input SignupUserPayloadWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_lt: String
  token_lte: String
  token_gt: String
  token_gte: String
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  AND: [SignupUserPayloadWhereInput!]
  OR: [SignupUserPayloadWhereInput!]
  NOT: [SignupUserPayloadWhereInput!]
}

input SignupUserPayloadWhereUniqueInput {
  id: ID
}

type Subscription {
  authenticateUserPayload(where: AuthenticateUserPayloadSubscriptionWhereInput): AuthenticateUserPayloadSubscriptionPayload
  event(where: EventSubscriptionWhereInput): EventSubscriptionPayload
  file(where: FileSubscriptionWhereInput): FileSubscriptionPayload
  group(where: GroupSubscriptionWhereInput): GroupSubscriptionPayload
  invite(where: InviteSubscriptionWhereInput): InviteSubscriptionPayload
  item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
  loggedInUserPayload(where: LoggedInUserPayloadSubscriptionWhereInput): LoggedInUserPayloadSubscriptionPayload
  signupUserPayload(where: SignupUserPayloadSubscriptionWhereInput): SignupUserPayloadSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
  email: String
  username: String!
  hosting(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event!]
  password: String
  groups(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Group!]
  invites(where: InviteWhereInput, orderBy: InviteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Invite!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  items: ItemCreateManyWithoutBringerInput
  email: String
  username: String!
  hosting: EventCreateManyWithoutHostedByInput
  password: String
  groups: GroupCreateManyWithoutMembersInput
  invites: InviteCreateManyWithoutUserInput
}

input UserCreateManyWithoutGroupsInput {
  create: [UserCreateWithoutGroupsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneWithoutHostingInput {
  create: UserCreateWithoutHostingInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutInvitesInput {
  create: UserCreateWithoutInvitesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutItemsInput {
  create: UserCreateWithoutItemsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutGroupsInput {
  items: ItemCreateManyWithoutBringerInput
  email: String
  username: String!
  hosting: EventCreateManyWithoutHostedByInput
  password: String
  invites: InviteCreateManyWithoutUserInput
}

input UserCreateWithoutHostingInput {
  items: ItemCreateManyWithoutBringerInput
  email: String
  username: String!
  password: String
  groups: GroupCreateManyWithoutMembersInput
  invites: InviteCreateManyWithoutUserInput
}

input UserCreateWithoutInvitesInput {
  items: ItemCreateManyWithoutBringerInput
  email: String
  username: String!
  hosting: EventCreateManyWithoutHostedByInput
  password: String
  groups: GroupCreateManyWithoutMembersInput
}

input UserCreateWithoutItemsInput {
  email: String
  username: String!
  hosting: EventCreateManyWithoutHostedByInput
  password: String
  groups: GroupCreateManyWithoutMembersInput
  invites: InviteCreateManyWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  email_ASC
  email_DESC
  username_ASC
  username_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String
  username: String!
  password: String
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  items: ItemUpdateManyWithoutBringerInput
  email: String
  username: String
  hosting: EventUpdateManyWithoutHostedByInput
  password: String
  groups: GroupUpdateManyWithoutMembersInput
  invites: InviteUpdateManyWithoutUserInput
}

input UserUpdateManyDataInput {
  email: String
  username: String
  password: String
}

input UserUpdateManyMutationInput {
  email: String
  username: String
  password: String
}

input UserUpdateManyWithoutGroupsInput {
  create: [UserCreateWithoutGroupsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutGroupsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutGroupsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredWithoutHostingInput {
  create: UserCreateWithoutHostingInput
  update: UserUpdateWithoutHostingDataInput
  upsert: UserUpsertWithoutHostingInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutInvitesInput {
  create: UserCreateWithoutInvitesInput
  update: UserUpdateWithoutInvitesDataInput
  upsert: UserUpsertWithoutInvitesInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutItemsInput {
  create: UserCreateWithoutItemsInput
  update: UserUpdateWithoutItemsDataInput
  upsert: UserUpsertWithoutItemsInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutGroupsDataInput {
  items: ItemUpdateManyWithoutBringerInput
  email: String
  username: String
  hosting: EventUpdateManyWithoutHostedByInput
  password: String
  invites: InviteUpdateManyWithoutUserInput
}

input UserUpdateWithoutHostingDataInput {
  items: ItemUpdateManyWithoutBringerInput
  email: String
  username: String
  password: String
  groups: GroupUpdateManyWithoutMembersInput
  invites: InviteUpdateManyWithoutUserInput
}

input UserUpdateWithoutInvitesDataInput {
  items: ItemUpdateManyWithoutBringerInput
  email: String
  username: String
  hosting: EventUpdateManyWithoutHostedByInput
  password: String
  groups: GroupUpdateManyWithoutMembersInput
}

input UserUpdateWithoutItemsDataInput {
  email: String
  username: String
  hosting: EventUpdateManyWithoutHostedByInput
  password: String
  groups: GroupUpdateManyWithoutMembersInput
  invites: InviteUpdateManyWithoutUserInput
}

input UserUpdateWithWhereUniqueWithoutGroupsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutGroupsDataInput!
}

input UserUpsertWithoutHostingInput {
  update: UserUpdateWithoutHostingDataInput!
  create: UserCreateWithoutHostingInput!
}

input UserUpsertWithoutInvitesInput {
  update: UserUpdateWithoutInvitesDataInput!
  create: UserCreateWithoutInvitesInput!
}

input UserUpsertWithoutItemsInput {
  update: UserUpdateWithoutItemsDataInput!
  create: UserCreateWithoutItemsInput!
}

input UserUpsertWithWhereUniqueWithoutGroupsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutGroupsDataInput!
  create: UserCreateWithoutGroupsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  hosting_every: EventWhereInput
  hosting_some: EventWhereInput
  hosting_none: EventWhereInput
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  groups_every: GroupWhereInput
  groups_some: GroupWhereInput
  groups_none: GroupWhereInput
  invites_every: InviteWhereInput
  invites_some: InviteWhereInput
  invites_none: InviteWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    